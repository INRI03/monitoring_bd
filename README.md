# Мониторинг состояния БД

### 1. Требуется изменить наименование файла-журнала БД на формат имени postgres-XXX, где ХХХ - день недели и включить ротирование файлов, так чтобы постоянно оставалось 7 файлов на каждый день недели.

Требуется открыть файл конфигурации Postgres (найти его можно SQL командой show config_file), найти в нем строку "log_filename" и прописать в ней значение 'postgresql-%a.log'. Маленькая буква 'a' будет означать сокращенный день недели. Далее в строке "log_rotation_age" прописать значение '1440', что означает новый файл лога 1 раз в день (1440 минут). И последнее - в строке "log_truncate_on_rotation" прописать 'on'. "Это будет означать затирание предыдущего файла и замену его на новый (ротация). Каждую из этих строк следует при необходимости раскомментировать (убрать перед ней символ #, если он есть). 
После этого следует сохранить файл конфигурации и перезагрузить саму конфигурацию. Это можно сделать командой select pg_reload_conf(). Поскольку у этих параметров контекст sighup, перезагрузка СУБД не обязательна.
Контекст я определил такой командой:
```sql
select name, setting, context from pg_settings
 where name in ('log_filename', 'log_rotation_age', 'log_truncate_on_rotation')
 ```

### 2. Необходимо включить запись событий подключения сессии пользователя и запись запроса, который выполняется больше 1 сек.

В том же файле конфигурации следует найти строку "log_connections", раскомментировать ее, если стоит символ #, и прописать значение "on" вместо "off". Далее следует также раскомментировать строку "log_min_duration_statement" и прописать значение 1000 (это означает 1000 миллисекунд, т.е. 1 секунда). После этого в лог будут заноситься запросы длительностью 1 и более секунд. Также само собой перезагрузить СУБД.

### 3. Воспользовавшись представлением статистики, необходимо увидеть и определить время подключения сессии, под которой вы сейчас работаете, её текущеее состояние и тип сессии backend_type.

Следует воспользоваться представлением pg_stat_acivity.  Чтобы выбрать тот процесс, в котором есть транзакция, то есть процесс, который инициировал человек, а не СУБД, можно выбрать процесс, в котором xact_start не пустой. Можно воспользоваться такой командой:

```sql
select backend_start, state, backend_type
from pg_stat_activity
where xact_start is not null 
```

Время начала сессии указано, состояние - active, тип сессии - client backend.

![pg_stat_acivity](https://github.com/INRI03/monitoring_bd/blob/main/01.png)

### 4. Во 2-ом терминале подключения к БД, выполнить команду отключения сеанса 1-го терминала.

Следует воспользоваться командой pg_terminate_backend, поскольку в задании нужно отключить сеанс, а не выполнение какой-то команды.

![02](https://github.com/INRI03/monitoring_bd/blob/main/02.png)
![03](https://github.com/INRI03/monitoring_bd/blob/main/03.png)

### 5. Определить ТОП-1 самых часто запускаемый запрос.

Пункты выполнения задачи:
1. В файле конфигурации в строке shared_preload_libraries (которую само собой нужно раскомментировать) прописать 'pg_stat_statements'.
2. Перезапустить СУБД.
3. Выполнить команду "CREATE EXTENSION pg_stat_statements".
4. Выполнить команду
```sql
 select query
 from pg_stat_statements
 where calls = (select max(calls)
 from pg_stat_statements)
 ```
  
 Подзапрос использую потому, что самых часто запускаемых запросов может быть больше чем один. А в случае с подзапросом я получаю все запросы с наибольшим количеством запусков.
  
 ![04](https://github.com/INRI03/monitoring_bd/blob/main/04.png)
